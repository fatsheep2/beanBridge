name: Sync DEG Updates

on:
  # 每天 UTC 时间 2:00 检查一次（北京时间 10:00）
  schedule:
    - cron: '0 2 * * *'
  # 也可以手动触发
  workflow_dispatch:
  # 当 double-entry-generator 发布新版本时触发（通过 webhook）
  repository_dispatch:
    types: [deg-updated]

permissions:
  contents: write
  pull-requests: write
  # 如果需要绕过分支保护规则，可能需要添加以下权限
  # 但通常不推荐，应该通过审批流程

# 并发控制：同一时间只运行一个 sync-deg 工作流
# 如果有新的运行，会取消旧的（避免重复同步）
concurrency:
  group: sync-deg-updates
  cancel-in-progress: true

jobs:
  sync-deg:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout beanBridge
        uses: actions/checkout@v4
        with:
          path: beanBridge
          fetch-depth: 0  # 获取所有分支和标签，以便后续可以 checkout main

      - name: Checkout double-entry-generator
        uses: actions/checkout@v4
        with:
          repository: deb-sig/double-entry-generator
          path: double-entry-generator
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Build WASM
        working-directory: double-entry-generator
        run: |
          # 构建 WASM，即使 Makefile 最后复制 wasm_exec.js 失败也继续
          # 因为我们的下一步会处理 wasm_exec.js 的复制
          make build-wasm || {
            echo "Makefile build-wasm failed (likely wasm_exec.js copy issue), checking if WASM file was generated..."
            if [ -f "wasm-dist/double-entry-generator.wasm" ]; then
              echo "✓ WASM file was generated successfully, continuing..."
            else
              echo "✗ WASM file was not generated, build failed"
              exit 1
            fi
          }
          ls -lh wasm-dist/

      - name: Copy wasm_exec.js if missing
        working-directory: double-entry-generator
        run: |
          # 如果 wasm_exec.js 不在 wasm-dist 目录中，从 GOROOT 或 toolchain 复制
          if [ ! -f "wasm-dist/wasm_exec.js" ]; then
            echo "wasm_exec.js not found in wasm-dist, searching for it..."
            GOROOT=$(go env GOROOT)
            echo "GOROOT: $GOROOT"
            
            # 首先尝试标准 GOROOT 路径
            if [ -f "$GOROOT/lib/wasm/wasm_exec.js" ]; then
              cp "$GOROOT/lib/wasm/wasm_exec.js" wasm-dist/
              echo "✓ Copied from $GOROOT/lib/wasm/wasm_exec.js"
            elif [ -f "$GOROOT/misc/wasm/wasm_exec.js" ]; then
              cp "$GOROOT/misc/wasm/wasm_exec.js" wasm-dist/
              echo "✓ Copied from $GOROOT/misc/wasm/wasm_exec.js"
            else
              echo "Not found in GOROOT, searching in toolchain paths..."
              
              # 使用 find 命令在常见位置查找 wasm_exec.js
              # 尝试 lib/wasm (Go 1.24+) 和 misc/wasm (旧版本)
              WASM_EXEC_PATH=$(find "$HOME/go/pkg/mod" -name "wasm_exec.js" \( -path "*/toolchain@*/lib/wasm/wasm_exec.js" -o -path "*/toolchain@*/misc/wasm/wasm_exec.js" \) 2>/dev/null | head -1)
              
              if [ -n "$WASM_EXEC_PATH" ] && [ -f "$WASM_EXEC_PATH" ]; then
                cp "$WASM_EXEC_PATH" wasm-dist/wasm_exec.js
                echo "✓ Copied from toolchain: $WASM_EXEC_PATH"
              else
                echo "Error: wasm_exec.js not found"
                echo "GOROOT: $GOROOT"
                echo "Searching in $GOROOT/lib/wasm:"
                ls -la "$GOROOT/lib/wasm/" 2>/dev/null || echo "lib/wasm not found"
                echo "Searching in $GOROOT/misc/wasm:"
                ls -la "$GOROOT/misc/wasm/" 2>/dev/null || echo "misc/wasm not found"
                echo "Searching in toolchain:"
                find "$HOME/go/pkg/mod" -name "wasm_exec.js" 2>/dev/null | head -5 || echo "No wasm_exec.js found in toolchain"
                exit 1
              fi
            fi
          else
            echo "✓ wasm_exec.js already exists in wasm-dist"
          fi
          ls -lh wasm-dist/

      - name: Copy WASM files
        run: |
          mkdir -p beanBridge/public/wasm
          cp double-entry-generator/wasm-dist/double-entry-generator.wasm beanBridge/public/wasm/
          cp double-entry-generator/wasm-dist/wasm_exec.js beanBridge/public/wasm/
          ls -lh beanBridge/public/wasm/

      - name: Sync example configs
        run: |
          # 同步所有 provider 的示例配置文件
          cd double-entry-generator
          if [ ! -d "example" ]; then
            echo "Warning: example directory not found"
            exit 0
          fi
          for provider_dir in example/*/; do
            # 检查目录是否存在（避免 glob 失败的情况）
            [ -d "$provider_dir" ] || continue
            provider=$(basename "$provider_dir")
            if [ -f "$provider_dir/config.yaml" ]; then
              echo "Syncing config for $provider..."
              mkdir -p "../beanBridge/public/example/$provider"
              cp "$provider_dir/config.yaml" "../beanBridge/public/example/$provider/" || {
                echo "Warning: Failed to copy config for $provider"
              }
            fi
          done
          echo "Synced example configs:"
          ls -la ../beanBridge/public/example/ || echo "No example configs synced"

      - name: Check for changes
        id: changes
        working-directory: beanBridge
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add public/wasm/ public/example/
          if git diff --staged --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes detected"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changes detected"
            git status
          fi

      - name: Prepare branch and commit
        if: steps.changes.outputs.has_changes == 'true'
        id: prepare
        working-directory: beanBridge
        run: |
          BRANCH_NAME="auto-sync-deg-$(date +%Y%m%d-%H%M%S)"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          git checkout -b "$BRANCH_NAME"
          git commit -m "chore: auto-sync DEG updates

          - Update WASM files from double-entry-generator
          - Sync example configurations
          - Auto-generated by GitHub Actions"
          git push origin "$BRANCH_NAME"

      - name: Create Pull Request
        if: steps.changes.outputs.has_changes == 'true'
        id: create-pr
        working-directory: beanBridge
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.prepare.outputs.branch_name }}"
          # 创建 PR（不添加标签，因为标签可能不存在）
          PR_OUTPUT=$(gh pr create \
            --title "Auto-sync DEG updates" \
            --body "This PR automatically syncs updates from double-entry-generator:
          - Updated WASM files
          - Synced example configurations
          
          Auto-generated by GitHub Actions workflow." \
            --base main \
            --head "$BRANCH_NAME" 2>&1) || {
            echo "PR creation failed or already exists: $PR_OUTPUT"
            # 尝试查找已存在的 PR
            EXISTING_PR=$(gh pr list --head "$BRANCH_NAME" --base main --json number --jq '.[0].number' 2>/dev/null || echo "")
            if [ -n "$EXISTING_PR" ]; then
              echo "Found existing PR: #$EXISTING_PR"
              echo "pr_number=$EXISTING_PR" >> $GITHUB_OUTPUT
            fi
            exit 0
          }
          
          # 提取 PR 编号
          PR_NUMBER=$(echo "$PR_OUTPUT" | grep -oP 'pull/\K\d+' | head -1 || echo "")
          if [ -n "$PR_NUMBER" ]; then
            echo "Created PR: #$PR_NUMBER"
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            # 尝试添加标签（如果存在），失败也不影响
            gh pr edit "$PR_NUMBER" --add-label "auto-merge" 2>/dev/null || echo "Label 'auto-merge' not found, skipping label addition"
            
            # 等待一下让 PR 完全创建
            sleep 2
            
            # 触发部署预览（通过 workflow_dispatch）
            echo "Triggering preview deployment for branch: $BRANCH_NAME"
            gh workflow run "Deploy Branch Preview to GitHub Pages" \
              --ref "$BRANCH_NAME" \
              --field branch="$BRANCH_NAME" 2>/dev/null || {
              echo "Failed to trigger deployment workflow (may need to wait for PR to be fully created)"
              echo "Deployment will be triggered automatically when PR is opened"
            }
          fi

      - name: Auto-merge Pull Request
        if: steps.changes.outputs.has_changes == 'true' && steps.create-pr.outputs.pr_number != ''
        working-directory: beanBridge
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.create-pr.outputs.pr_number }}"
          echo "Attempting to auto-merge PR #$PR_NUMBER..."
          
          # 等待一下确保 PR 已创建（workflow_dispatch 时可能需要更长时间）
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            sleep 10
          else
            sleep 5
          fi
          
          # 获取 PR 详细信息
          PR_INFO=$(gh pr view "$PR_NUMBER" --json state,mergeable,mergeStateStatus,isDraft 2>/dev/null || echo '{}')
          MERGEABLE=$(echo "$PR_INFO" | jq -r '.mergeable // "null"')
          MERGE_STATE=$(echo "$PR_INFO" | jq -r '.mergeStateStatus // "unknown"')
          IS_DRAFT=$(echo "$PR_INFO" | jq -r '.isDraft // false')
          
          echo "PR mergeable: $MERGEABLE"
          echo "PR merge state: $MERGE_STATE"
          echo "PR is draft: $IS_DRAFT"
          
          # 如果是草稿，先发布
          if [ "$IS_DRAFT" = "true" ]; then
            echo "Publishing draft PR..."
            gh pr ready "$PR_NUMBER" || echo "Failed to publish draft"
            sleep 2
          fi
          
          # 检查 PR 的审批状态
          REVIEWS=$(gh pr view "$PR_NUMBER" --json reviews --jq '.reviews[] | select(.state == "APPROVED") | .author.login' 2>/dev/null | sort -u || echo "")
          APPROVED_COUNT=$(echo "$REVIEWS" | grep -c . || echo "0")
          echo "Approved by: $REVIEWS ($APPROVED_COUNT reviewers)"
          
          # 检查 PR 是否可以合并
          if [ "$MERGEABLE" = "true" ] && [ "$MERGE_STATE" != "BLOCKED" ]; then
            echo "PR is mergeable, attempting to merge..."
            # 使用 squash merge 并删除分支
            gh pr merge "$PR_NUMBER" \
              --squash \
              --delete-branch \
              --body "Auto-merged by GitHub Actions workflow" || {
              echo "Merge failed, checking detailed status..."
              gh pr view "$PR_NUMBER" --json mergeable,mergeStateStatus,statusCheckRollup,reviewDecision || true
              
              # 如果是因为需要审批，尝试再次合并（可能审批刚通过）
              if [ "$APPROVED_COUNT" -gt 0 ]; then
                echo "PR has approvals, retrying merge..."
                sleep 3
                gh pr merge "$PR_NUMBER" \
                  --squash \
                  --delete-branch \
                  --body "Auto-merged by GitHub Actions workflow (approved PR)" || {
                  echo "Retry merge also failed"
                  exit 0
                }
                echo "✓ PR #$PR_NUMBER merged successfully on retry"
              else
                exit 0
              fi
            }
            echo "✓ PR #$PR_NUMBER merged successfully"
          else
            echo "PR is not ready to merge"
            echo "Mergeable: $MERGEABLE, Merge state: $MERGE_STATE"
            
            # 显示 PR 状态信息
            echo "PR status checks:"
            gh pr checks "$PR_NUMBER" || true
            
            # 显示审批状态
            echo "PR reviews:"
            gh pr view "$PR_NUMBER" --json reviews --jq '.reviews[] | "\(.state): \(.author.login)"' || true
            
            # 如果已审批但不可合并，可能是检查未通过，尝试设置 auto-merge
            if [ "$APPROVED_COUNT" -gt 0 ]; then
              echo "PR has approvals but merge state is BLOCKED"
              
              # 检查检查状态
              FAILED_CHECKS=$(gh pr view "$PR_NUMBER" --json statusCheckRollup --jq '[.statusCheckRollup[] | select(.conclusion == "FAILURE" or .conclusion == "ACTION_REQUIRED")] | length' 2>/dev/null || echo "0")
              PENDING_CHECKS=$(gh pr view "$PR_NUMBER" --json statusCheckRollup --jq '[.statusCheckRollup[] | select(.status == "PENDING" or .status == "IN_PROGRESS")] | length' 2>/dev/null || echo "0")
              
              echo "Failed checks: $FAILED_CHECKS"
              echo "Pending checks: $PENDING_CHECKS"
              
              if [ "$FAILED_CHECKS" -eq 0 ] && [ "$PENDING_CHECKS" -eq 0 ] && [ "$MERGE_STATE" = "BLOCKED" ]; then
                echo "No failed or pending checks but still BLOCKED, may be branch protection rule"
                echo "Attempting to enable auto-merge..."
                gh pr merge "$PR_NUMBER" --auto --squash 2>&1 || {
                  echo "Auto-merge not available"
                  echo "Note: PR may require bypassing branch protection rules manually"
                  echo "Or adjust branch protection rules to allow auto-merge for approved PRs"
                }
              else
                echo "Enabling auto-merge (will merge when checks pass)..."
                gh pr merge "$PR_NUMBER" --auto --squash 2>&1 || {
                  echo "Auto-merge not available or failed"
                  echo "PR will be merged automatically when all checks pass"
                }
              fi
            else
              echo "PR needs approval before it can be merged"
            fi
          fi


